# File: laptop_ai/flow_field.py

import numpy as np

class FlowFieldAvoidance:
    """
    Provides DJI-level smooth obstacle avoidance using a potential-field
    / vector-field blending method.

    Instead of abrupt direction changes, this system produces smooth
    flow-curves around obstacles, blending with the cinematic Bézier
    curve generated by UltraDirector.
    """

    def __init__(self, influence_radius=5.0, repulsion_strength=8.0):
        self.influence_radius = influence_radius
        self.repulsion_strength = repulsion_strength

    # -----------------------------------------------------------
    # D1. Compute repulsion force field from obstacles
    # -----------------------------------------------------------
    def compute_repulsion(self, point, obstacles):
        """
        Computes total repulsion vector from all obstacles.
        point = [x, y, z]
        obstacles = list of [x, y, z]
        """

        total_force = np.array([0.0, 0.0, 0.0])

        for obs in obstacles:
            obs = np.array(obs)
            diff = point - obs
            dist = np.linalg.norm(diff)

            if dist == 0 or dist > self.influence_radius:
                continue

            # Repulsion strength increases as we get closer
            strength = self.repulsion_strength * (1.0 / (dist**2))

            # Direction away from obstacle
            force = (diff / dist) * strength
            total_force += force

        return total_force

    # -----------------------------------------------------------
    # D2. Bend curve point by blending with repulsion flow-field
    # -----------------------------------------------------------
    def blend_point(self, base_point, obstacles):
        """
        Takes a Bézier curve sample point and bends it safely using flow-field repulsion.
        """

        repulsion = self.compute_repulsion(base_point, obstacles)

        # Blend ratio
        alpha = 0.25  # 25% repulsion, 75% original cinematic intent
        blended = base_point + (repulsion * alpha)

        return blended

    # -----------------------------------------------------------
    # D3. Process entire curve into flow-field-safe curve
    # -----------------------------------------------------------
    def warp_curve(self, curve, obstacles, samples=50):
        """
        curve: original BézierCurve
        returns new flow-field warped curve point sampler
        """

        if curve is None:
            return None

        # Precompute warped points
        warped_points = []
        ts = np.linspace(0, 1, samples)

        for t in ts:
            p = curve.point(t)
            safe_p = self.blend_point(p, obstacles)
            warped_points.append(safe_p)

        # Convert back into a smooth parametric function
        def sampler(t):
            """Smooth interpolated curve"""
            t = np.clip(t, 0, 1)
            idx = int(t * (samples - 1))
            return warped_points[idx]

        return sampler
